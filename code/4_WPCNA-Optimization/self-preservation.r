#!/usr/bin/env Rscript

## Examine module self-preservation using the NetRep R package.
#  Partitions of the protein co-expression graph generated by the Leiden 
#  algorithm (e.g. partitions.csv) are provided as input. 
#  Modules that are not preserved agains the null (random) model are set to zero.

# FIXME: insure input and output are loaded from correct directories.

#-------------------------------------------------------------------------------
## # Set-up the workspace.
#-------------------------------------------------------------------------------

# Global options and imports.
options(stringsAsFactors = FALSE)
suppressPackageStartupMessages({
	library(igraph)
	library(NetRep)
})

# Directories.
here <- getwd()
root <- dirname(dirname(here))
fun  <- paste(root,"functions", sep="/") 
tables <- paste(root,"tables", sep="/") 

# Load expression data and compute adjmatrix:
type <- 2 # WT or KO
data <- c("wtDat.Rds","koDat.Rds")[type]
cleanDat <- readRDS(data)
adjm <- silently(WGCNA::bicor, cleanDat)

# Read network partition info.
# Module labels are int. Add 1 so that all module membership > 0.
partition_file <- c("wtAdjm_partitions.csv", "koAdjm_partitions.csv")[type]
clufile <- paste(tables, partition_file, sep = "/")
cluDat <- read.csv(clufile) + 1 
partitions <- split(cluDat, seq(nrow(cluDat)))

#-------------------------------------------------------------------------------
# ## Enforce module self-preservation.
#-------------------------------------------------------------------------------
# Remove modules that are not preserved (i.e. have insignificant module
# preservation statistics). This computation is expensive and will take several
# hours to 1 day.

# Input for NetRep:
data_list        <- list(data = cleanDat) # The protein expression data.
correlation_list <- list(data = adjm) # The bicor correlation matrix.
network_list     <- list(data = adjm)  # The weighted, signed co-expresion network.

# Empty list for output of loop.
preserved_partitions <- list()

for (i in seq_along(partitions)){
	message(paste("Enforcing module self-preservation: working on partition", i ,"..."))
	# Get partition
	module_labels <- as.vector(as.matrix(partitions[[i]])) 
	names(module_labels) <- colnames(cleanDat)
	nModules <- length(unique(module_labels))
	module_list <- list(data = module_labels)
	# Perform permutation test for self-preservation.
	preservation <- NetRep::modulePreservation(
						   network = network_list,
		  				   data = data_list,
				      		   correlation = correlation_list,
				  		   moduleAssignments = module_list,
						   modules = NULL,
						   backgroundLabel = NULL,
						   discovery = "data",
						   test = "data",
						   selfPreservation = TRUE,
						   nThreads = 8, 
						   #nPerm = 100000, 
						   null = "overlap",
						   alternative = "greater",
						   simplify = TRUE,
						   verbose = TRUE
						   )
	# Get the maximum permutation test p-value.
	maxp <- apply(preservation$p.values, 1, function(x) max(x, na.rm = TRUE))
	# Modules removed if adjusted pvalue is greater than alpha = 0.05.
	alpha <- 0.05
	modules_out <- names(maxp)[maxp > alpha / nModules]
	nModules_out <- length(modules_out)
	if (length(nModules_out) > 0) {
		idx <- module_labels %in% modules_out
		module_labels[idx] <- 0
	}
	# Return module membership.
	preserved_partitions[[i]] <- module_labels
}

# Save output as RDS.
saveRDS(preserved_partitions, "ko_preserved_partitions.Rds")

# ENDOFILE
#------------------------------------------------------------------------------
