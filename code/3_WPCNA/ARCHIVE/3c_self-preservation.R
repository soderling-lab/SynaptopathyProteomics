#!/usr/bin/env Rscript
# Examine module self-preservation using the NetRep R package.
# Partitions of the protein co-expression graph generated by the Leiden 
# algorithm (e.g. partitions.csv) are provided as input. 
# Modules that are not preserved against the null (random) model are removed 
# (set to zero).

# INPUT: 
# * la-partitions.csv: partitions of co-expression graph.
# * adjm.csv: protein co-expression graph.

# OUTPUT:
# * preserved_partitions.Rds

#-------------------------------------------------------------------------------
## Set-up the workspace.
#-------------------------------------------------------------------------------

# Global options and imports.
suppressPackageStartupMessages({
	library(igraph)
	library(NetRep)
})

# Directories.
here <- getwd()
root <- dirname(dirname(here))
fun  <- file.path(root,"functions") 
data <- file.path(root,"data")
tables <- file.path(root,"tables") 

# Custom functions.
source(file.path(fun,"0_Functions.R"))

# Load expression data and sample info. 
myfile <- file.path(data, "2_Combined_TAMPOR_cleanDat.Rds")
cleanDat <- readRDS(myfile)
myfile <- file.path(data, "2_Combined_traits.Rds")
sample_info <- readRDS(myfile)

# Remove QC data.
out <- rownames(sample_info)[sample_info$SampleType == "QC"]
idy <- colnames(cleanDat) %in% out
cleanDat <- t(log2(cleanDat[,!idy]))

# Compute bicor adjacency matrix.
adjm <- silently(WGCNA::bicor, cleanDat)

# Read network partition info.
# Module labels are int. Add 1 so that all module membership > 0.
clufile <- file.path(here, "la-partitions.csv")
cluDat <- read.csv(clufile, header = TRUE, row.names = 1, as.is = TRUE) + 1
partitions <- split(cluDat, seq(nrow(cluDat)))

#-------------------------------------------------------------------------------
# ## Enforce module self-preservation.
#-------------------------------------------------------------------------------
# Remove modules that are not preserved (i.e. have insignificant module
# preservation statistics). This computation is expensive and will take several
# hours to 1 day.

# Input for NetRep:
data_list        <- list(data = cleanDat) # The protein expression data.
correlation_list <- list(data = adjm)     # The bicor correlation matrix.
network_list     <- list(data = adjm)     # The weighted, signed co-expresion network.

# Empty list for output of loop.
preserved_partitions <- list()

# Loop to determine preserved clusters in every partition.
for (i in seq_along(partitions)){
	message(paste("Enforcing module self-preservation: working on partition", i ,"..."))
	# Get partition
	module_labels <- as.vector(as.matrix(partitions[[i]])) 
	names(module_labels) <- colnames(cleanDat)
	nModules <- length(unique(module_labels))
	module_list <- list(data = module_labels)
	# Perform permutation test for self-preservation.
	preservation <- NetRep::modulePreservation(
						   network = network_list,
		  				   data = data_list,
				      		   correlation = correlation_list,
				  		   moduleAssignments = module_list,
						   modules = NULL,
						   backgroundLabel = NULL,
						   discovery = "data",
						   test = "data",
						   selfPreservation = TRUE,
						   nThreads = 8, 
						   #nPerm = 100000, 
						   null = "overlap",
						   alternative = "greater",
						   simplify = TRUE,
						   verbose = TRUE
						   )
	# Get the maximum permutation test p-value.
	maxp <- apply(preservation$p.values, 1, function(x) max(x, na.rm = TRUE))
	# Modules removed if adjusted pvalue is greater than alpha = 0.05.
	alpha <- 0.05
	modules_out <- names(maxp)[maxp > alpha / nModules]
	nModules_out <- length(modules_out)
	if (length(nModules_out) > 0) {
		idx <- module_labels %in% modules_out
		module_labels[idx] <- 0
	}
	# Return module membership.
	preserved_partitions[[i]] <- module_labels
}

# Save output as RDS.
myfile <- file.path(data, paste0(exp,"_preserved_partitions.Rds"))
saveRDS(preserved_partitions, myfile)

# ENDOFILE
#------------------------------------------------------------------------------
