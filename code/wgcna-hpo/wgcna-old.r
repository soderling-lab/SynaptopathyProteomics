#!/usr/bin/env Rscript

## Usage:
# wgcna.r [data.Rds] [--parameters] 

# This script performs Weighted Gene (or Protein) Co-expression Analysis (WGCNA).
# The analysis is broken into three chunks:
# * Parsing the users input.
# * Prepaaring a named list of parameters for WGCNA.
# * Performing WGCNA and identifying appropriate soft-thresholding power, beta.
# * Analysis of the quality of the partition.

# The wgcna() function is a wrapper around WGCNA::BlockWiseModules(). This funciton
# performs WGCNA using the user's provided data and (optional) hyperparameters.
# If parameters are not provided, then the defaults will be used. 
# If a power for weighting the network is not provided,
# then it will be chosen such that the overall topology of the weighted 
# network is approximately scale free (R^2 > 0.8).

# Note: the default power is 9, and this is not appropriate for all datasets.
# Set power to NULL, if you wish to calculate the best soft-thresholding power.

###############################################################################
# Load data for testing if no command line arguments passed.
if (length(commandArgs(trailingOnly=FALSE)) == 0){
  print("Using test data!")
  options(stringsAsFactors = FALSE)
  dir <- "D:/projects/Synaptopathy-Proteomics/code/wgcna-hpo"
  setwd(dir)
  data_file  <- paste(dir, "exprDat.Rds", sep="/")
  params_file <- paste(dir, "parameters.txt", sep="/")
  exprDat <- readRDS(data_file)
  temp_params <- read.delim(params_file, header = FALSE, col.names = c("Parameter","Value"))
  temp_params$Value[temp_params$Value == "True"] <- TRUE
  temp_params$Value[temp_params$Value == "False"] <- FALSE
  temp_params <- temp_params[!(temp_params$Value == "None"),]
  user_params <- as.list(temp_params$Value)
  names(user_params) <- temp_params$Parameter
}

###############################################################################

#------------------------------------------------------------------------------
# ## Parse the command line arguments.
#------------------------------------------------------------------------------

# FIXME: add ability to specify input data in .csv format.

# Global options:
options(stringsAsFactors = FALSE)
require(argparser, quietly = TRUE)

# Check for input data before proceeding.
if(length(commandArgs(trailingOnly=TRUE)) == 0) {
  msg <- paste("Please provide normalized n x m matrix of expression data as input for WGCNA!",
               "Use ./wgcna.r --help for help.", sep = "\n")
  stop(msg)
}

# Parse the command line arguments.
p <- arg_parser("Perform WGCNA given a normalized n x m matrix of protein or gene expression data. ")
p <- add_argument(p, "data", 
		  help = paste("normalized n (sample) x m (gene) expression matrix",
		               "provided as a .Rds file in the same directory as this script"),
		  default = NULL)
p <- add_argument(p, "--parameters", short = "-p", 
		  help = "optional parameters for WGCNA algorithm", 
		  default = NULL)
p <- add_argument(p, c("-ch", "-db", "-sc"), flag = c(TRUE, TRUE, TRUE),
		  help = c("Calinski-Harabasz", "Davies-Bouldin", "Silhouette coefficient"),
		  default = as.list(c(FALSE, FALSE, FALSE)))

args <- parse_args(p)

# Check flags.
if (all(args$ch == FALSE, 
	args$db == FALSE,
	args$sc == FALSE)) {
	message("No quality index was specified. Using Calinski-Harabasz (ch) as default!")
	args$ch <- TRUE
}

# Load data as n x m normalized expression matrix. 
dir <- getwd()
data_file <- paste(dir, args$data, sep="/")
exprDat <- readRDS(data_file)

# If provided, parse the user's hyperparameters.
if (!is.na(args$parameters)) {
  params_file <- paste(dir, args$parameters, sep="/")
  temp_params <- read.delim(params_file, header = FALSE, col.names = c("Parameter","Value"))
  
  # Replace True/False with TRUE/FALSE
  temp_params$Value[temp_params$Value == "True"] <- TRUE
  temp_params$Value[temp_params$Value == "False"] <- FALSE
  
  # Remove 'None' type arguments. These will be replaced with defaults.
  temp_params <- temp_params[!(temp_params$Value == "None"),]
  
  # Format as list. 
  user_params <- as.list(temp_params$Value)
  names(user_params) <- temp_params$Parameter
  
  # If no parameters passed, defaults will be generated by get_wgcna_params().
  } else if (is.na(args$parameters)) {
    user_params <- args$parameters
  } else {
    stop("Unable to parse user provided parameters.")
  }

#------------------------------------------------------------------------------
# ## Define default WGCNA parameters.
#------------------------------------------------------------------------------

## Given expression data matrix and optional user defined parameters, 
#  define parameters for WGCNA analysis. 

## INPUT: 
# exprDat - normalized n x m matrix of gene or protein expression data.
# user_params - named list of user defined WGCNA parameters.
## OUTPUT:
# parameters - named list of WGCNA parameters to be passed to wgcna() function.

get_wgcna_params <- function(exprDat, user_params = NULL){
  
  # Global options:
  options(stringsAsFactors = FALSE)
  
  # WGCNA Parameters:
  keys <- c("weights", "checkMissingData", "blocks", "maxBlockSize", "blockSizePenaltyPower", 
            "nPreclusteringCenters", "randomSeed", 'loadTOM', 'corType', 'maxPOutliers', 
            "quickCor", "pearsonFallback", "cosineCorrelation", "power", "networkType", 
            "replaceMissingAdjacencies", "suppressTOMForZeroAdjacencies", 'TOMType', 
            'TOMDenom', 'getTOMs', 'saveTOMs', "saveTOMFileBase", "deepSplit", 
            "detectCutHeight", "minModuleSize", "maxCoreScatter", 'minGap', 'maxAbsCoreScatter',
            "minAbsGap", 'minSplitHeight', 'minAbsSplitHeight', 'useBranchEigennodeDissim', 
            'minBranchEigennodeDissim', 'stabilityLabels', 'stabilityCriterion', 
            'minStabilityDissim', 'pamStage', 'pamRespectsDendro', 'reassignThreshold', 
            'minCoreKME', 'minCoreKMESize', 'minKMEtoStay', 'mergeCutHeight', 'impute', 
            'trapErrors', 'numericLabels', 'nThreads', 'useInternalMatrixAlgebra', 
            'useCorOptionsThroughout', 'verbose', 'indent')
  default_params <- vector("list", length(keys))
  names(default_params) <- keys
  
  ## Define defaults. Ignore NULL defaults.
  
  # Input data
  #default_params$exprDat <- exprDat
  #default_params$weights <- NULL
  
  # Data checking options
  default_params$checkMissingData <- FALSE
  
  # Options for splitting data into blocks
  #default_params$blocks                <- NULL
  default_params$maxBlockSize          <- 15000
  default_params$blockSizePenaltyPower <- 5
  default_params$nPreclusteringCenters <- as.integer(min(ncol(exprDat)/20, 100*ncol(exprDat)/default_params$maxBlockSize))
  default_params$randomSeed            <- 12345
  
  # load TOM from previously saved file?
  default_params$loadTOM <- FALSE
  
  # Network construction arguments: correlation options
  default_params$corType           <- "bicor"
  default_params$maxPOutliers      <- 1
  default_params$quickCor          <- 0
  default_params$pearsonFallback   <- "individual"
  default_params$cosineCorrelation <- FALSE
  
  # Adjacency function options
  default_params$power                         <- 13
  default_params$networkType                   <- "signed"
  default_params$replaceMissingAdjacencies     <- FALSE
  default_params$suppressTOMForZeroAdjacencies <- FALSE
  
  # Topological overlap options
  default_params$TOMType  <- "signed"  # c()
  default_params$TOMDenom <- "min"     # c("min","mean")
  
  # Saving or returning TOM
  #default_params$getTOMs         <- NULL
  default_params$saveTOMs        <- FALSE 
  default_params$saveTOMFileBase <- "blockwiseTOM"
  
  # Basic tree cut options
  default_params$deepSplit       <- 2
  default_params$detectCutHeight <- 0.995 
  default_params$minModuleSize   <- min(20, ncol(exprDat)/2)
  
  # Advanced tree cut options
  # default_params$maxCoreScatter           <- NULL 
  # default_params$minGap                   <- NULL
  # default_params$maxAbsCoreScatter        <- NULL
  # default_params$minAbsGap                <- NULL
  # default_params$minSplitHeight           <- NULL
  # default_params$minAbsSplitHeight        <- NULL
  default_params$useBranchEigennodeDissim <- FALSE
  default_params$minBranchEigennodeDissim <- 0.15
  # default_params$stabilityLabels          <- NULL
  default_params$stabilityCriterion       <- "Individual fraction" # c("Individual fraction", "Common fraction")
  # default_params$minStabilityDissim       <- NULL
  default_params$pamStage                 <- TRUE
  default_params$pamRespectsDendro        <- TRUE
  
  # Gene reassignment, module trimming, and module "significance" criteria
  default_params$reassignThreshold <- 1e-6
  default_params$minCoreKME        <- 0.5
  default_params$minCoreKMESize    <- round(min(20, ncol(exprDat)/2)/3)
  default_params$minKMEtoStay      <- 0.3
  
  # Module merging options
  default_params$mergeCutHeight <- 0.15
  default_params$impute         <- TRUE
  default_params$trapErrors     <- FALSE
  
  # Output options
  default_params$numericLabels <- FALSE
  
  # Options controlling behaviour
  default_params$nThreads                 <- 8
  default_params$useInternalMatrixAlgebra <- FALSE
  default_params$useCorOptionsThroughout  <- TRUE
  default_params$verbose                  <- 0 
  default_params$indent                   <- 0
  
  # If provided, overwrite default parameters with user provided ones.
  if (inherits(user_params, "list")) {
  idx <- match(names(user_params), names(default_params))
  #message(paste0(length(idx), ": user defined parameters utilized!"))
  params <- default_params
  params[idx] <- user_params
  # Insure that params are the correct data type. Ignore NULLS.
  params <- lapply(params, function(x) if(!is.null(x)) { type.convert(x) })
  # Make sure factors are converted back to characters!
  idx <- c(1:length(params))[unlist(lapply(params, function(x) is.factor(x)))]
  params[idx] <- unlist(lapply(params[idx], function(x) as.character(x)))
  return(params)
  # Otherwise, use the defaults.
  } else if (is.null(user_params) | is.na(user_params)) {
    message("No user defined parameters. Using default WGCNA parameters!")
    params <- default_params
    return(params)
    } else {
      stop("please provide a list of parameters, or use the defaults.")
    }
}
	
parameters <- get_wgcna_params(exprDat, user_params)

#------------------------------------------------------------------------------
# ## Define a function to perform WGCNA.
#------------------------------------------------------------------------------

wgcna <- function(exprDat, params) {
  
  # Use tryCatch to handle errors caused by parameters which return a single module.
  tryCatch(
    {
      ## Global options and imports. 
      options(stringsAsFactors=FALSE)
      suppressPackageStartupMessages({
      	require(WGCNA)
      	require(doParallel)
      	require(parallel)
      })
      
        # Allow parallel WGCNA calculations if nThreads is > 0.
        if (params$nThreads > 0) {
          # Use sink to supress unwanted output.
          temp <- tempfile()
          sink(temp) 
          allowWGCNAThreads(nThreads = params$nThreads)
          sink(NULL)
          unlink(temp)
          clusterLocal <- makeCluster(c(rep("localhost", params$nThreads)), type = "SOCK")
          registerDoParallel(clusterLocal)
        }
      
        # Function to get best power, suppressing unwanted output with sink.
        pickPower <- function(...){
          temp <- tempfile()
          sink(temp) 
          output <- WGCNA::pickSoftThreshold(...)
          sink(NULL)
          unlink(temp)
          return(output)
        }
        
        # If no power was provided, then determine the best power to achieve ~scale free toplogy. 
        if (is.null(params$power)) {
      	  message("Picking the best soft thresholding power to achieve scale free fit > 0.8!")
          sft <- pickPower(
            data        = exprDat,
            dataIsExpr  = TRUE,
            weights     = params$weights,
            RsquaredCut = 0.80,
            powerVector = seq(2, 20, by = 1.0),
            removeFirst = FALSE, 
            nBreaks     = 10, 
            corFnc      = params$corType,
            corOptions  = list(use = 'p'),
            blockSize   = params$maxBlockSize,
            networkType = params$networkType,
            moreNetworkConcepts = FALSE,
            gcInterval  = NULL,
            verbose     = params$verbose,
            indent      = params$indent
          )
          
          # Calculate the best power_beta.
          params$power <- sft$powerEstimate
	  message(paste("Best soft-threshold power, beta:", sft$powerEstimate))
        }
          
          ## Perform WGCNA by calling the blockwiseModules() function.
          # Function to supress unwanted output from the blockwiseModules with sink().
          blockwiseWGCNA <- function(...){
            temp <- tempfile()
            sink(temp) 
            output <- WGCNA::blockwiseModules(...)
            sink(NULL)
            unlink(temp)
            return(output)
        }
          
          net <- blockwiseWGCNA(
              # Input data
              datExpr               = exprDat, 
              weights               = params$weights,
              
              # Data checking options
              checkMissingData      = params$checkMissingData,
              
              # Options for splitting data into blocks
              blocks                = params$blocks,
              maxBlockSize          = params$maxBlockSize,
              blockSizePenaltyPower = params$blockSizePenaltyPower,
              nPreclusteringCenters = params$nPreclusteringCenters,
              randomSeed            = params$randomSeed,
              
              # load TOM from previously saved file? This will speed things up. 
              loadTOM               = params$loadTOM,
              
              # Network construction arguments: correlation options
              corType               = params$corType,
              maxPOutliers          = params$maxPOutliers, 
              quickCor              = params$quickCor,
              pearsonFallback       = params$pearsonFallback,
              cosineCorrelation     = params$cosineCorrelation,
              
              # Adjacency function options
              power                     = params$power,
              networkType               = params$networkType,
              replaceMissingAdjacencies = params$replaceMissingAdjacencies,
              
              # Topological overlap options
              TOMType                       = params$TOMType,
              TOMDenom                      = params$TOMDenom,
              suppressTOMForZeroAdjacencies = params$suppressTOMForZeroAdjacencies,
              suppressNegativeTOM           = params$suppressNegativeTOM,
              
              # Saving or returning TOM
              getTOMs         = params$getTOMs,
              saveTOMs        = params$saveTOMs, 
              saveTOMFileBase = params$saveTOMFileBase,
              
              # Basic tree cut options
              deepSplit       = params$deepSplit,
              detectCutHeight = params$detectCutHeight,
              minModuleSize   = params$minModuleSize,
              
              # Advanced tree cut options
              maxCoreScatter           = params$maxCoreScatter, 
              minGap                   = params$minGap,
              maxAbsCoreScatter        = params$maxAbsCoreScatter, 
              minAbsGap                = params$minAbsGap,
              minSplitHeight           = params$minSplitHeight, 
              minAbsSplitHeight        = params$minAbsSplitHeight,
              useBranchEigennodeDissim = params$useBranchEigennodeDissim,
              minBranchEigennodeDissim = params$mergeCutHeight,
              stabilityLabels          = params$stabilityLabels,
              stabilityCriterion       = params$stabilityCriterion,
              minStabilityDissim       = params$minStabilityDissim,
              pamStage                 = params$pamStage, 
              pamRespectsDendro        = params$pamRespectsDendro,
              
              # Gene reassignment, module trimming, and module "significance" criteria
              reassignThreshold  = params$reassignThreshold,
              minCoreKME         = params$minCoreKME, 
              minCoreKMESize     = round(params$minModuleSize/3),
              minKMEtoStay       = params$minKMEtoStay,
              
              # Module merging options
              mergeCutHeight = params$mergeCutHeight, 
              impute         = params$impute, 
              trapErrors     = params$trapErrors, 
              
              # Output options
              numericLabels = params$numericLabels,
              
              # Options controlling behaviour
              nThreads                 = params$nThreads,
              useInternalMatrixAlgebra = params$useInternalMatrixAlgebra,
              useCorOptionsThroughout  = params$useCorOptionsThroughout,
              verbose                  = params$verbose, 
              indent                   = params$indent)
          
          return(list("data" = exprDat, "network" = net, "hyperparameters" = params))
    }, 
    # Catch error messages. 
    error = function(cond) {
      stop("Error: unable to perform WGCNA!")
    },
    # Catch warning messages.
    # TryCatch() will abort code prematurely, so we need to close sink opened above.
    # Otherwise stdout will be sopped up by sink.
    warning = function(cond) {
      sink(NULL) 
      unlink(temp)
      message("Warning: unable to complete analysis! Likely cause: WGCNA returned 0 or 1 module.")
      print(100) # a bad score
      quit()
      }, 
    finally = {
      # wrap up code if you want. 
    }
  )
} # Ends wgcna()

## Perform WGCNA!
results <- wgcna(exprDat, parameters)

#------------------------------------------------------------------------------
# ## Evaluate quality of the WGCNA partition.
#------------------------------------------------------------------------------

# FIXME: catch xlaunch error and tell the user to use bin/xlaunch
# FIXME: need to add ability to specify which quality metric.

suppressPackageStartupMessages({
  require(clusterSim, quietly = TRUE)
})

# Extract WGCNA results.
exprDat <- results$data
net <- results$network
params <- results$hyperparameters

# The number of modules and percent grey.
nmodules <- length(unique(results$network$colors)) - 1 # exclude grey

# Stop if nModules < 2, as we cannot compute quality statistics with fewer than 2 modules. 
if (nmodules < 2) {
	message("Error: cannot compute quality indices if nModules < 2.0")
	print(100) # A bad score
	quit()
}

# Progress report.
msg <- paste("... Total nModules:", nmodules)
message(msg)

# Calculate percent grey (unclustered nodes):
is_grey <- net$colors == "grey"
percent_grey <- sum(is_grey)/length(is_grey)
message(paste("... Percent grey  :", round(percent_grey,3)))

# Calculate median percent variance explained, module cohesivness:
pve <- WGCNA::propVarExplained(exprDat, net$colors, net$MEs, corFnc = params$corType)
median_pve <- median(pve[!names(pve) == "PVEgrey"]) # exclude grey
message(paste("... Median PVE    :", round(median_pve,3)))

# Remove grey nodes from data.
subDat <- exprDat[,!is_grey]

# Calculate weighted signed adjacency matrix.
sink(tempfile())
adjm <- ((1 + bicor(subDat))/ 2)^params$power
sink(NULL)

# Calcualte cluster quality index.
cl <- as.integer(as.numeric(as.factor(net$colors[!is_grey])))
if (args$ch == TRUE) {
	# Calculate Calinski-Harabasz index
	ch_index <- index.G1(adjm, cl)
	score <- 1000*(1/ch_index * percent_grey)
	print(score)
} else if (args$db == TRUE) {
	# Calculate Davies-Bouldin index
	db_index <- index.DB(adjm, cl)$DB
	score <- 1000 * db_index * percent_grey
	print(score)
} else if (args$sc == TRUE) {
	# Calculate Silhouette coefficient, using TOM diss matrix.
	diss <- 1 - TOMsimilarity(
				  adjm, 
				  TOMType  = params$TOMType,
				  TOMDenom = params$TOMDenom,
				  suppressTOMForZeroAdjacencies = params$suppressTOMForZeroAdjacencies,
				  useInternalMatrixAlgebra      = params$useInternalMatrixAlgebra,
				  verbose  = params$verbose,
				  indent   = params$indent
				  )
	sc_index <- index.S(as.dist(diss), cl)
	score <- (1/sc_index * percent_grey)
	print(score)
} else {
	stop("Please specify a cluster quality index: c('ch', 'db', 'sc')")
}

